# -*- coding: utf-8 -*-
"""econ_compute.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hYmqzB5_AwvymYIMzIBGiRDGJaSz972_
"""

import math
import inspect

# --- Compound Interest Forward ---
def calculate_compound_interest(P, r, n, t):
    """
    A = P * (1 + r/n)^(n*t)
    """
    A = P * (1 + r / n) ** (n * t)
    return round(A, 2), "A = P * (1 + r/n)^(n*t)"

# --- Compound Interest Reverse: Principal ---
def calculate_principal_from_compound(A, r, n, t):
    """
    P = A / (1 + r/n)^(n*t)
    """
    P = A / (1 + r / n) ** (n * t)
    return round(P, 2), "P = A / (1 + r/n)^(n*t)"

# --- Compound Interest Reverse: Rate (numeric approx) ---
def calculate_rate_from_compound(P, A, n, t, tol=1e-8, max_iter=1000):
    """
    Numerically solve for r in A = P*(1 + r/n)^(n*t)
    Uses Newton-Raphson method
    """
    r = 0.05  # initial guess
    for i in range(max_iter):
        f = P * (1 + r / n) ** (n * t) - A
        if abs(f) < tol:
            return round(r, 8), "Numerically solved r in compound interest"
        df = P * (n * t) * (1 + r / n) ** (n * t - 1) / n
        if df == 0:
            break
        r_new = r - f / df
        if abs(r_new - r) < tol:
            return round(r_new, 8), "Numerically solved r in compound interest"
        r = r_new
    raise ValueError("Rate calculation did not converge")

# --- Return on Investment ---
def calculate_roi(gain, cost):
    """
    ROI = (Gain - Cost) / Cost
    """
    if cost == 0:
        raise ValueError("Cost cannot be zero")
    roi = (gain - cost) / cost
    return round(roi, 4), "ROI = (Gain - Cost) / Cost"

# --- Break-even Point ---
def calculate_break_even(fixed_costs, price_per_unit, variable_cost_per_unit):
    """
    Break-even units = Fixed Costs / (Price per unit - Variable cost per unit)
    """
    denominator = price_per_unit - variable_cost_per_unit
    if denominator == 0:
        raise ValueError("Price per unit must be greater than variable cost per unit")
    break_even_units = fixed_costs / denominator
    return round(break_even_units, 2), "Break-even units = Fixed Costs / (Price - Variable Cost)"

# --- Net Present Value ---
def calculate_npv(discount_rate, cash_flows):
    """
    NPV = Sum of discounted cash flows
    cash_flows: list where index = period (0 = now)
    """
    npv = 0
    for i, cf in enumerate(cash_flows):
        npv += cf / ((1 + discount_rate) ** i)
    return round(npv, 2), "NPV = Î£ (Cash Flow / (1 + r)^t)"

# --- Future Value of Annuity ---
def calculate_future_value_annuity(payment, rate_per_period, periods):
    """
    FV = payment * [((1 + r)^n - 1) / r]
    """
    if rate_per_period == 0:
        fv = payment * periods
    else:
        fv = payment * ((1 + rate_per_period) ** periods - 1) / rate_per_period
    return round(fv, 2), "FV = payment * [((1 + r)^n - 1) / r]"

# --- Simple Interest ---
def calculate_simple_interest(P, r, t):
    """
    I = P * r * t
    """
    I = P * r * t
    return round(I, 2), "I = P * r * t"

# --- Payback Period ---
def calculate_payback_period(initial_investment, annual_cash_inflow):
    """
    Payback Period = Initial Investment / Annual Cash Inflow
    """
    if annual_cash_inflow == 0:
        raise ValueError("Annual cash inflow cannot be zero")
    period = initial_investment / annual_cash_inflow
    return round(period, 2), "Payback Period = Initial Investment / Annual Cash Inflow"

# --- Placeholder formulas you can add later ---
def calculate_price_elasticity_of_demand(percent_change_quantity, percent_change_price):
    """
    PED = % change in quantity demanded / % change in price
    """
    if percent_change_price == 0:
        raise ValueError("Percent change in price cannot be zero")
    ped = percent_change_quantity / percent_change_price
    return round(ped, 4), "PED = % change in quantity demanded / % change in price"

def calculate_gdp_growth_rate(gdp_t, gdp_t_minus_1):
    """
    Growth Rate = ((GDP_t - GDP_{t-1}) / GDP_{t-1}) * 100%
    """
    if gdp_t_minus_1 == 0:
        raise ValueError("Previous GDP cannot be zero")
    growth_rate = ((gdp_t - gdp_t_minus_1) / gdp_t_minus_1) * 100
    return round(growth_rate, 2), "Growth Rate = ((GDP_t - GDP_{t-1}) / GDP_{t-1}) * 100%"

def calculate_debt_to_equity(total_debt, shareholders_equity):
    """
    Debt-to-Equity = Total Debt / Shareholders' Equity
    """
    if shareholders_equity == 0:
        raise ValueError("Shareholders' equity cannot be zero")
    ratio = total_debt / shareholders_equity
    return round(ratio, 4), "Debt-to-Equity = Total Debt / Shareholders' Equity"

def calculate_inventory_turnover(cost_of_goods_sold, average_inventory):
    """
    Inventory Turnover = Cost of Goods Sold / Average Inventory
    """
    if average_inventory == 0:
        raise ValueError("Average inventory cannot be zero")
    turnover = cost_of_goods_sold / average_inventory
    return round(turnover, 2), "Inventory Turnover = Cost of Goods Sold / Average Inventory"

def calculate_contribution_margin(price_per_unit, variable_cost_per_unit):
    """
    Contribution Margin = Price per unit - Variable cost per unit
    """
    margin = price_per_unit - variable_cost_per_unit
    return round(margin, 2), "Contribution Margin = Price per unit - Variable cost per unit"

def calculate_operating_profit_margin(operating_income, revenue):
    """
    Operating Profit Margin = (Operating Income / Revenue) * 100%
    """
    if revenue == 0:
        raise ValueError("Revenue cannot be zero")
    margin = (operating_income / revenue) * 100
    return round(margin, 2), "Operating Profit Margin = (Operating Income / Revenue) * 100%"

# --- Present Value of Future Sum ---
def calculate_present_value(FV, r, t):
    """
    PV = FV / (1 + r)^t
    """
    PV = FV / (1 + r) ** t
    return round(PV, 2), "PV = FV / (1 + r)^t"

# --- Capital Asset Pricing Model (CAPM) ---
def calculate_capm(risk_free_rate, beta, market_return):
    """
    Expected Return = Risk-free Rate + beta * (Market Return - Risk-free Rate)
    """
    expected_return = risk_free_rate + beta * (market_return - risk_free_rate)
    return round(expected_return, 4), "Expected Return = Risk-free Rate + beta * (Market Return - Risk-free Rate)"

# --- Elasticity of Supply ---
def calculate_elasticity_of_supply(percent_change_quantity_supplied, percent_change_price):
    """
    Elasticity = % change in quantity supplied / % change in price
    """
    if percent_change_price == 0:
        raise ValueError("Percent change in price cannot be zero")
    elasticity = percent_change_quantity_supplied / percent_change_price
    return round(elasticity, 4), "Elasticity = % change in quantity supplied / % change in price"

# --- Debt Service Coverage Ratio (DSCR) ---
def calculate_dscr(net_operating_income, total_debt_service):
    """
    DSCR = Net Operating Income / Total Debt Service
    """
    if total_debt_service == 0:
        raise ValueError("Total debt service cannot be zero")
    dscr = net_operating_income / total_debt_service
    return round(dscr, 4), "DSCR = Net Operating Income / Total Debt Service"

# --- Economic Order Quantity (EOQ) ---
def calculate_eoq(demand, ordering_cost, holding_cost):
    """
    EOQ = sqrt(2 * D * S / H)
    """
    if holding_cost == 0:
        raise ValueError("Holding cost cannot be zero")
    eoq = math.sqrt((2 * demand * ordering_cost) / holding_cost)
    return round(eoq, 2), "EOQ = sqrt(2 * Demand * Ordering Cost / Holding Cost)"

# --- Weighted Average Cost of Capital (WACC) ---
def calculate_wacc(E, V, Re, D, Rd, Tc):
    """
    WACC = (E/V)*Re + (D/V)*Rd*(1 - Tc)
    E = Market value of equity
    V = Total market value of equity and debt
    Re = Cost of equity
    D = Market value of debt
    Rd = Cost of debt
    Tc = Corporate tax rate
    """
    if V == 0:
        raise ValueError("Total market value (V) cannot be zero")
    wacc = (E / V) * Re + (D / V) * Rd * (1 - Tc)
    return round(wacc, 4), "WACC = (E/V)*Re + (D/V)*Rd*(1 - Tc)"

# --- Mark-up Pricing ---
def calculate_markup_price(cost, markup_percentage):
    """
    Price = Cost + (Cost * Markup Percentage)
    """
    price = cost + (cost * markup_percentage)
    return round(price, 2), "Price = Cost + (Cost * Markup Percentage)"

# Registry of supported formulas
SUPPORTED_FUNCTIONS = {
    "compound_interest": calculate_compound_interest,
    "principal_from_compound": calculate_principal_from_compound,
    "rate_from_compound": calculate_rate_from_compound,
    "roi": calculate_roi,
    "break_even": calculate_break_even,
    "npv": calculate_npv,
    "future_value_annuity": calculate_future_value_annuity,
    "simple_interest": calculate_simple_interest,
    "payback_period": calculate_payback_period,
    "price_elasticity_of_demand": calculate_price_elasticity_of_demand,
    "gdp_growth_rate": calculate_gdp_growth_rate,
    "debt_to_equity": calculate_debt_to_equity,
    "contribution_margin": calculate_contribution_margin,
    "inventory_turnover": calculate_inventory_turnover,
    "operating_profit_margin": calculate_operating_profit_margin,
    "present_value": calculate_present_value,
    "capm": calculate_capm,
    "elasticity_of_supply": calculate_elasticity_of_supply,
    "dscr": calculate_dscr,
    "eoq": calculate_eoq,
    "wacc": calculate_wacc,
    "markup_price": calculate_markup_price,
}

'''
# --- Add to existing SUPPORTED_FUNCTIONS ---
additional_functions = {

}

SUPPORTED_FUNCTIONS.update(additional_functions)
'''

def execute_formula(formula_name, params):
    """
    Executes the requested formula with given parameters.
    Returns (result, formula_string).
    """
    if formula_name not in SUPPORTED_FUNCTIONS:
        raise NotImplementedError(f"Formula '{formula_name}' is not implemented in econ_compute")

    func = SUPPORTED_FUNCTIONS[formula_name]

    # Filter only required params for the function
    func_params = inspect.signature(func).parameters
    filtered_params = {k: params[k] for k in func_params if k in params}

    return func(**filtered_params)