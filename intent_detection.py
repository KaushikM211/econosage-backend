# -*- coding: utf-8 -*-
"""intent_detection

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1TiHCbwkMgQJUrBbq2Uq2WwuGftRdSLLd
"""

import re

# Map keywords to formula names
INTENT_KEYWORDS = {
    "compound_interest": ["compound interest", "compound", "interest"],
    "principal_from_compound": ["principal from compound", "principal", "initial amount"],
    "rate_from_compound": ["rate from compound", "interest rate", "rate of return"],
    "roi": ["return on investment", "roi"],
    "break_even": ["break even", "breakeven"],
    "npv": ["net present value", "npv"],
    "future_value_annuity": ["future value annuity", "annuity"],
    "simple_interest": ["simple interest"],
    "payback_period": ["payback period"],
    "price_elasticity_of_demand": ["price elasticity of demand", "elasticity of demand"],
    "gdp_growth_rate": ["gdp growth rate", "economic growth rate"],
    "debt_to_equity": ["debt to equity", "debt-equity ratio"],
    "contribution_margin": ["contribution margin"],
    "inventory_turnover": ["inventory turnover"],
    "operating_profit_margin": ["operating profit margin"],
    "present_value": ["present value"],
    "capm": ["capm", "capital asset pricing model"],
    "elasticity_of_supply": ["elasticity of supply"],
    "dscr": ["debt service coverage ratio", "dscr"],
    "eoq": ["economic order quantity", "eoq"],
    "wacc": ["weighted average cost of capital", "wacc"],
    "markup_price": ["markup pricing", "markup price"],
}

# Regex patterns for extracting numbers and common parameters
PARAM_PATTERNS = {
    "P": r"principal(?: amount)?[:= ]*([\d\.]+)",
    "r": r"rate(?: of interest| rate)?[:= ]*([\d\.]+)%",
    "n": r"compounded (\d+) times",
    "t": r"time(?: period| in years)?[:= ]*([\d\.]+)",
    "A": r"amount[:= ]*([\d\.]+)",
    "gain": r"gain[:= ]*([\d\.]+)",
    "cost": r"cost[:= ]*([\d\.]+)",
    "fixed_costs": r"fixed costs?[:= ]*([\d\.]+)",
    "price_per_unit": r"price per unit[:= ]*([\d\.]+)",
    "variable_cost_per_unit": r"variable cost per unit[:= ]*([\d\.]+)",
    "discount_rate": r"discount rate[:= ]*([\d\.]+)%",
    "cash_flows": r"cash flows?[:= ]*\[([\d\., ]+)\]",
    "payment": r"payment[:= ]*([\d\.]+)",
    "rate_per_period": r"rate per period[:= ]*([\d\.]+)%",
    "periods": r"periods?[:= ]*([\d\.]+)",
    "initial_investment": r"initial investment[:= ]*([\d\.]+)",
    "annual_cash_inflow": r"annual cash inflow[:= ]*([\d\.]+)",

    # Newly added patterns:
    "percent_change_quantity": r"percent(?:age)? change in quantity[:= ]*([\d\.]+)%",
    "percent_change_price": r"percent(?:age)? change in price[:= ]*([\d\.]+)%",
    "gdp_t": r"gdp(?: at time t)?[:= ]*([\d\.]+)",
    "gdp_t_minus_1": r"gdp(?: at time t-1)?[:= ]*([\d\.]+)",
    "total_debt": r"total debt[:= ]*([\d\.]+)",
    "shareholders_equity": r"shareholders'? equity[:= ]*([\d\.]+)",
    "operating_income": r"operating income[:= ]*([\d\.]+)",
    "revenue": r"revenue[:= ]*([\d\.]+)",
    "risk_free_rate": r"risk[- ]free rate[:= ]*([\d\.]+)%",
    "beta": r"beta[:= ]*([\d\.]+)",
    "market_return": r"market return[:= ]*([\d\.]+)%",
    "percent_change_quantity_supplied": r"percent(?:age)? change in quantity supplied[:= ]*([\d\.]+)%",
    "net_operating_income": r"net operating income[:= ]*([\d\.]+)",
    "total_debt_service": r"total debt service[:= ]*([\d\.]+)",
    "demand": r"demand[:= ]*([\d\.]+)",
    "ordering_cost": r"ordering cost[:= ]*([\d\.]+)",
    "holding_cost": r"holding cost[:= ]*([\d\.]+)",
    "E": r"market value of equity[:= ]*([\d\.]+)",
    "V": r"total market value[:= ]*([\d\.]+)",
    "Re": r"cost of equity[:= ]*([\d\.]+)%",
    "D": r"market value of debt[:= ]*([\d\.]+)",
    "Rd": r"cost of debt[:= ]*([\d\.]+)%",
    "Tc": r"corporate tax rate[:= ]*([\d\.]+)%",
    "markup_percentage": r"markup(?: percentage)?[:= ]*([\d\.]+)%",
}

def extract_numbers(text):
    """Extract all floats from text."""
    return [float(x) for x in re.findall(r"[-+]?\d*\.\d+|\d+", text)]

def extract_params(user_text):
    """
    Try to extract parameters from user text based on PARAM_PATTERNS.
    Returns dict with params as floats.
    """
    params = {}
    for param, pattern in PARAM_PATTERNS.items():
        match = re.search(pattern, user_text, re.IGNORECASE)
        if match:
            val = match.group(1)
            try:
                val = float(val)
                # For rates given as percentages, convert to decimals
                if 'rate' in param or 'r' == param or 'discount_rate' == param or 'rate_per_period' == param:
                    if val > 1:
                        val = val / 100
                params[param] = val
            except:
                continue
    # Special case: cash_flows as list
    if "cash_flows" in params and isinstance(params["cash_flows"], str):
        try:
            cf_str = params["cash_flows"]
            cf_list = [float(x.strip()) for x in cf_str.split(",")]
            params["cash_flows"] = cf_list
        except:
            pass
    return params

def detect_intent(user_text):
    """
    Detect formula intent based on keywords in user_text.
    Returns formula_name or None.
    """
    text = user_text.lower()
    for formula, keywords in INTENT_KEYWORDS.items():
        for kw in keywords:
            if kw in text:
                return formula
    return None

def parse_user_query(user_text):
    """
    Returns (formula_name, params_dict) if detected, else (None, {}).
    """
    intent = detect_intent(user_text)
    if intent is None:
        return None, {}

    params = extract_params(user_text)
    return intent, params